#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <sys/wait.h>

/**
 * Struct contains train data
 */
struct train
{

    char train_direction[2];
    int load_time;
    int cross_time;
};

/**
 * Gets the priority of the train direction
 *
 * @param dir The direction of the train and priority
 * @return The priority
 *
 * Generated by ChatGPT
 */
int get_priority(char dir)
{
    if (dir == 'W' || dir == 'E')
        return 2; // High priority
    if (dir == 'w' || dir == 'e')
        return 1; // Low priority
    return 0;     // Invalid case (should not happen)
}

/*
    Priority Queue Implementation
    Sources - https://www.geeksforgeeks.org/c-program-to-implement-priority-queue/ & ChatGPT
*/

typedef struct
{
    char t_dir[75];
    int train_index[75];
    int size;
} PriorityQueue;

/**
 * Swaps two char variables
 *
 * @param a1 The first variable that swaps with a2
 * @param a2 The second variable that swaps with a1
 */
void swap2(char *a1, char *a2)
{
    char temp = *a1;
    *a1 = *a2;
    *a2 = temp;
}

/**
 * Swaps two int variables
 *
 * @param a1 The first variable that swaps with a2
 * @param a2 The second variable that swaps with a1
 */
void swap(int *a1, int *a2)
{
    int temp = *a1;
    *a1 = *a2;
    *a2 = temp;
}

/**
 * Checks if the min heap structure is maintained. If not, then it will correct it by comparing
 * if the parent is greater than child. Swaps anything that is true to the statement.
 *
 * @param train A priority queue which holds the loading_time for the train
 * @param index The index of the current train
 */
void heapifyUp(PriorityQueue *train, int index)
{
    if (index == 0)
    {
        return;
    }

    int parent = (index - 1) / 2;

    int curr_priority = get_priority(train->t_dir[index]);
    int parent_priority = get_priority(train->t_dir[parent]);

    if (curr_priority > parent_priority ||
        (curr_priority == parent_priority && train->train_index[index] < train->train_index[parent]))
    {
        swap2(&train->t_dir[parent], &train->t_dir[index]);
        swap(&train->train_index[parent], &train->train_index[index]);
        heapifyUp(train, parent);
    }
}

/**
 * Adds new loading time values to priority queue
 *
 * @param train The priority queue to that holds load time
 * @param value The new train direction to be inserted into train which defines priority
 * @param value2 The new index to be inserted into train
 */
void enqueue(PriorityQueue *train, char value, int value2)
{
    if (train->size == 75)
    {
        printf("Queue is full\n");
        return;
    }

    train->t_dir[train->size] = value;
    train->train_index[train->size] = value2;
    heapifyUp(train, train->size);
    train->size++;

}

/**
 * Checks if min heap structure is maintained at bottom.
 * If not, it will swap left or right with current index.
 *
 * @param train The priority queue that contains load time
 * @param index The index of the current train
 */
void heapifyDown(PriorityQueue *train, int index)
{
    int left = 2 * index + 1;  // Left child
    int right = 2 * index + 2; // Right child
    int highest = index;

    if (left < train->size &&
        (get_priority(train->t_dir[left]) > get_priority(train->t_dir[highest]) ||
         (get_priority(train->t_dir[left]) == get_priority(train->t_dir[highest]) &&
          train->train_index[left] < train->train_index[highest])))
    {
        highest = left;
    }

    if (right < train->size &&
        (get_priority(train->t_dir[right]) > get_priority(train->t_dir[highest]) ||
         (get_priority(train->t_dir[right]) == get_priority(train->t_dir[highest]) &&
          train->train_index[right] < train->train_index[highest])))
    {
        highest = right;
    }

    if (highest != index)
    {
        swap2(&train->t_dir[index], &train->t_dir[highest]);
        swap(&train->train_index[index], &train->train_index[highest]);
        heapifyDown(train, highest);
    }
}

/**
 * Takes out the top item in a priority queue
 *
 * @param train The priority queue that contains load time
 * @return Returns the first index in priority queue
 */
int dequeue(PriorityQueue *train)
{
    if (train->size == 0)
    {
        printf("Priority Queue is empty\n");
        return -1;
    }

    int eject = train->train_index[0];
    char eject_dir = train->t_dir[0];

    train->train_index[0] = train->train_index[train->size - 1];
    train->t_dir[0] = train->t_dir[train->size - 1];

    train->size--;

    if (train->size > 0)
    {
        heapifyDown(train, 0);
    }

    return eject;
}

/**
 * Peeks at the first item in the priority queue
 *
 * @param train The priority queue that contains load time
 * @return Returns the first index in priority queue
 */
int peek(PriorityQueue *train)
{
    if (train->size == 0)
    {
        printf("Train is empty\n");
        return -1;
    }
    return train->train_index[0];
}

PriorityQueue train_west = {{0}, 0}; /* Initialized priority queue */
PriorityQueue train_east = {{0}, 0};

struct timespec start, end; /* Beginning and end of clock timer */
long elapsed_seconds = 0;
long elapsed_nanoseconds = 0;

/**
 * Begins a timer
 */
void begin_time()
{
    int time = clock_gettime(CLOCK_REALTIME, &start);

    if (time == -1)
    {
        printf("Error in time\n");
        return;
    }
}

struct train train_data[75]; /* Holds train attributes */
pthread_mutex_t count_mutex; /* Holds mutex */
pthread_mutex_t main_lock;   /* locks the main function */
pthread_mutex_t train_mutex_west;
pthread_mutex_t train_mutex_east;
pthread_mutex_t track;

pthread_cond_t count_cond; /* Holds conditions */
pthread_cond_t count_cond2;

int load_done = 0; /* Checks if loading time is done. 0: Not done, 1: done */
int load_done2 = 0;
char last_direction = 'E';

/**
 * Prints the current time
 */
void get_time(char *buffer, size_t size)
{
    int time = clock_gettime(CLOCK_REALTIME, &end);

    if (time == -1)
    {
        printf("Clock error");
        return;
    }

    /* Line 195 - 211: Generated by ChatGPT */
    elapsed_seconds = end.tv_sec - start.tv_sec;
    elapsed_nanoseconds = end.tv_nsec - start.tv_nsec;

    if (elapsed_nanoseconds < 0)
    {
        elapsed_seconds -= 1;
        elapsed_nanoseconds += 1000000000;
    }

    int hours = elapsed_seconds / 3600;
    int minutes = (elapsed_seconds % 3600) / 60;
    int seconds = elapsed_seconds % 60;
    int milliseconds = elapsed_nanoseconds / 1000000;

    snprintf(buffer, size, "%02d:%02d:%02d.%01d", hours, minutes, seconds, milliseconds / 100);
}

/**
 * Loads the train threads using usleep() and loading time
 *
 * @param index The index of current train being loaded
 */
void *loading_time(void *index)
{
    char *train_direction_l = train_data[(intptr_t)index].train_direction;
    int load_time_l = train_data[(intptr_t)index].load_time;
    int index_l = (intptr_t)index;

    double new_time = (double)(load_time_l) / 10;
    unsigned int load_time2 = new_time * 1000000;
    usleep(load_time2); /* Loads time */

    char time_buffer[20]; // Buffer to hold formatted timestamp
    get_time(time_buffer, sizeof(time_buffer));

    pthread_mutex_lock(&count_mutex);
    char *direction;
    if (strcmp(train_direction_l, "W") == 0 || strcmp(train_direction_l, "w") == 0)
    {
        direction = "West";
    }
    else
    {
        direction = "East";
    }

    printf("%s Train %2d is ready to go %s\n", time_buffer, index_l, direction);

    pthread_mutex_unlock(&count_mutex);

    if (strcmp(train_direction_l, "W") == 0 || strcmp(train_direction_l, "w") == 0)
    {
        pthread_mutex_lock(&train_mutex_west);
        enqueue(&train_west, load_time_l, index_l);
        pthread_mutex_unlock(&train_mutex_west);
    }
    else
    {
        pthread_mutex_lock(&train_mutex_east);
        enqueue(&train_east, load_time_l, index_l);
        pthread_mutex_unlock(&train_mutex_east);
    }

    pthread_mutex_lock(&count_mutex);
    load_done = 1;
    pthread_cond_broadcast(&count_cond); /* Signals load time is finished */
    pthread_mutex_unlock(&count_mutex);

    pthread_exit(NULL);
}

/**
 * Where train enters track and exits track
 *
 * @param index The index of the current train on the track
 */
void *train_departs(void *index)
{

    int t_ind = (intptr_t)index;
    char time_buffer2[20]; /* Buffers that hold the time */
    char time_buffer[20];

    /* Output train on track */
    char *t_dir = train_data[t_ind].train_direction;
    int cross_time_l = train_data[t_ind].cross_time;

    double new_cross_time = (double)(cross_time_l) / 10;
    unsigned int load_time2 = (unsigned int)((cross_time_l / 10.0) * 1000000);

    char *dir;
    if (strcmp(t_dir, "W") == 0 || strcmp(t_dir, "w") == 0)
    {
        dir = "West";
    }
    else
    {
        dir = "East";
    }

    pthread_mutex_lock(&track);

    get_time(time_buffer, sizeof(time_buffer));

    pthread_mutex_lock(&count_mutex);
    /* Output that train is on main track */
    printf("%s Train %2d is ON the main track going %4s\n", time_buffer, t_ind, dir);
    pthread_mutex_unlock(&count_mutex);

    usleep(load_time2); /* Loads time */
    get_time(time_buffer2, sizeof(time_buffer2));

    pthread_mutex_lock(&count_mutex);
    /* Output that train is OFF the main track */
    printf("%s Train %2d is OFF the main track after going %4s\n", time_buffer2, t_ind, dir);
    pthread_mutex_unlock(&count_mutex);
    pthread_mutex_unlock(&track);

    pthread_exit(NULL);
}

/**
 * Finds the next train index to access
 *
 * @return The next index to access
 */
int find_index()
{

    int train_ind_wl = train_west.train_index[0];
    int train_ind_el = train_east.train_index[0];

    int train_wl_load = train_data[train_ind_wl].load_time;
    int train_el_load = train_data[train_ind_el].load_time;

    int train_wl_priority = get_priority(train_west.t_dir[0]);
    int train_el_priority = get_priority(train_east.t_dir[0]);

    if (train_west.size < 1 && train_east.size < 1)
    { /* Empty queue */
        return -1;
    }

    if (train_west.size == 0 && train_east.size > 0)
    { /* Train is only going west*/
        last_direction = 'E';
        return peek(&train_east);
    }

    if (train_west.size > 0 && train_east.size == 0)
    { /* Train is only going east */
        last_direction = 'W';
        return peek(&train_west);
    }

    if (train_wl_priority > train_el_priority)
    {
        last_direction = 'W';
        return peek(&train_west);
    }

    if (train_wl_priority < train_el_priority)
    {
        last_direction = 'E';
        return peek(&train_east);
    }

    if (train_wl_priority == train_el_priority)
    {

        if (train_wl_load < train_el_load)
        {
            last_direction = 'W';
            return peek(&train_west);
        }
        else if (train_wl_load > train_el_load)
        {
            last_direction = 'E';
            return peek(&train_east);
        }

        if (train_ind_wl > train_ind_el)
        {
            last_direction = 'E';
            return peek(&train_east);
        }
        else
        {
            last_direction = 'W';
            return peek(&train_west);
        }

        if (last_direction == 'W')
        {
            last_direction = 'E';
            return peek(&train_east);
        }
        else
        {
            last_direction = 'W';
            return peek(&train_west);
        }
    }
    return -1;
}

int main(int argc, char **argv)
{
    pthread_t threads[75];
    pthread_t thread2;

    int j = -1;

    pthread_mutex_init(&count_mutex, NULL); /* Initializes mutex */
    pthread_mutex_init(&main_lock, NULL);
    pthread_mutex_init(&train_mutex_west, NULL);
    pthread_mutex_init(&train_mutex_east, NULL);
    pthread_mutex_init(&track, NULL);

    pthread_cond_init(&count_cond, NULL); /* Initializes condition */
    pthread_cond_init(&count_cond2, NULL);

    FILE *input = fopen(argv[1], "r");
    if (input == NULL)
    {
        printf("Error: File is not available\n");
        return -1;
    }

    int num_trains = 0; /* Scans and gets the train data onto struct */
    while (!feof(input))
    {
        fscanf(input, "%s %d %d\n", train_data[num_trains].train_direction, &train_data[num_trains].load_time, &train_data[num_trains].cross_time);
        num_trains++;
    }

    begin_time(); /* Begins clock timer */

    for (int i = 0; i < num_trains; i++)
    {
        pthread_create(&threads[i], NULL, loading_time, (void *)(intptr_t)i); /* Loads the trains and decides which train to enter the main track */
    }

    for (int i = 0; i < num_trains; i++)
    { /* Waits until train is ready to cross */

        pthread_mutex_lock(&count_mutex);
        while (load_done == 0)
        {
            pthread_cond_wait(&count_cond, &count_mutex);
        }
        load_done = 0;
        pthread_mutex_unlock(&count_mutex);

        int j = find_index();
        if (j == -1)
        {
            pthread_mutex_unlock(&count_mutex);
            break;
        }

        if (train_data[j].train_direction[0] == 'W' || train_data[j].train_direction[0] == 'w')
        {
            dequeue(&train_west);
        }
        else
        {
            dequeue(&train_east);
        }

        pthread_create(&thread2, NULL, train_departs, (void *)(intptr_t)j);
    }

    for (int i = 0; i < num_trains; i++)
    {
        pthread_join(threads[i], NULL); /* Wait for threads to all complete */
    }

    for (int i = 0; i < num_trains; i++)
    {
        pthread_join(thread2, NULL);
    }

    pthread_mutex_destroy(&count_mutex);
    pthread_mutex_destroy(&main_lock);
    pthread_mutex_destroy(&train_mutex_west);
    pthread_mutex_destroy(&train_mutex_east);
    pthread_mutex_destroy(&track);

    pthread_cond_destroy(&count_cond);
    pthread_cond_destroy(&count_cond2);

    pthread_exit(NULL);
}