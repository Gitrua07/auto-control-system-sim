#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <sys/wait.h>

/**
 * Struct contains train data
 */
struct train
{

    char train_direction[2];
    int load_time;
    int cross_time;
};

/**
 * Gets the priority of the train direction
 *
 * @param dir The direction of the train and priority
 * @return The priority
 *
 * Generated by ChatGPT
 */
int get_priority(char dir)
{
    if (dir == 'W' || dir == 'E')
        return 2; // High priority
    if (dir == 'w' || dir == 'e')
        return 1; // Low priority
    return 0;     // Invalid case (should not happen)
}

/*
    Priority Queue Implementation - Line 42 to 233
    Sources - https://www.geeksforgeeks.org/c-program-to-implement-priority-queue/ & ChatGPT
*/

typedef struct
{
    char t_dir[75];
    int train_index[75];
    // temp
    double ready_time[75];
    // temp
    int size;
} PriorityQueue;

/**
 * Swaps two char variables
 *
 * @param a1 The first variable that swaps with a2
 * @param a2 The second variable that swaps with a1
 */
void swap2(char *a1, char *a2)
{
    char temp = *a1;
    *a1 = *a2;
    *a2 = temp;
}

/**
 * Swaps two int variables
 *
 * @param a1 The first variable that swaps with a2
 * @param a2 The second variable that swaps with a1
 */
void swap(int *a1, int *a2)
{
    int temp = *a1;
    *a1 = *a2;
    *a2 = temp;
}

/**
 * Checks if the min heap structure is maintained. If not, then it will correct it by comparing
 * if the parent is greater than child. Swaps anything that is true to the statement.
 * Uses train direction, ready time, and index to define heap order.
 * If train direction = W or E then high priority 
 * ow. if train direction = w or e then low priority
 * If curr_priority is higher than parent_priority priority then swap 
 * If equal then it will prioritize train w/ least ready time,
 * o.w if ready time is equal then train that has lowest index is prioritized
 *
 * @param train A priority queue which holds the loading_time for the train
 * @param index The index of the current train
 */
void heapifyUp(PriorityQueue *train, int index)
{
    if (index == 0)
    {
        return;
    }

    int parent = (index - 1) / 2;

    int curr_priority = get_priority(train->t_dir[index]);
    int parent_priority = get_priority(train->t_dir[parent]);

    if (curr_priority > parent_priority ||
        (curr_priority == parent_priority &&
         (train->ready_time[index] < train->ready_time[parent] ||
          (train->ready_time[index] == train->ready_time[parent] && train->train_index[index] < train->train_index[parent]))))
    {
        swap2(&train->t_dir[parent], &train->t_dir[index]);
        swap(&train->train_index[parent], &train->train_index[index]);
        double temp = train->ready_time[parent];
        train->ready_time[parent] = train->ready_time[index];
        train->ready_time[index] = temp;
        heapifyUp(train, parent);
    }
}

/**
 * Adds new loading time values to priority queue
 *
 * @param train The priority queue to that holds load time
 * @param value The new train direction to be inserted into train which defines priority
 * @param value2 The new index to be inserted into train
 */
void enqueue(PriorityQueue *train, char value, int value2, double value3)
{
    if (train->size == 75)
    {
        printf("Queue is full\n");
        return;
    }

    train->t_dir[train->size] = value;
    train->train_index[train->size] = value2;
    train->ready_time[train->size] = value3;
    heapifyUp(train, train->size);
    train->size++;
}

/**
 * Checks if min heap structure is maintained at bottom.
 * If not, it will swap left or right with current index.
 * Uses train direction, ready time, and index to define heap order.
 * If train direction = W or E then high priority 
 * ow. if train direction = w or e then low priority
 * If curr_priority is higher than parent_priority priority then swap 
 * If equal then it will prioritize train w/ least ready time,
 * o.w if ready time is equal then train that has lowest index is prioritized
 *
 * @param train The priority queue that contains load time
 * @param index The index of the current train
 */
void heapifyDown(PriorityQueue *train, int index)
{
    int left = 2 * index + 1;  /* Left child */
    int right = 2 * index + 2; /* Right child */
    int highest = index; /* Index with highest priority */

    if (left < train->size &&
        (get_priority(train->t_dir[left]) > get_priority(train->t_dir[highest]) ||
         (get_priority(train->t_dir[left]) == get_priority(train->t_dir[highest]) &&
          (train->ready_time[left] < train->ready_time[highest] ||
           (train->ready_time[left] == train->ready_time[highest] &&
            train->train_index[left] < train->train_index[highest])))))
    {
        highest = left;
    }

    if (right < train->size &&
        (get_priority(train->t_dir[right]) > get_priority(train->t_dir[highest]) ||
         (get_priority(train->t_dir[right]) == get_priority(train->t_dir[highest]) &&
          (train->ready_time[right] < train->ready_time[highest] ||
           (train->ready_time[right] == train->ready_time[highest] && train->train_index[right] < train->train_index[highest])))))
    {
        highest = right;
    }

    if (highest != index)
    {
        swap2(&train->t_dir[index], &train->t_dir[highest]);
        swap(&train->train_index[index], &train->train_index[highest]);
        double temp = train->ready_time[highest];
        train->ready_time[highest] = train->ready_time[index];
        train->ready_time[index] = temp;
        heapifyDown(train, highest);
    }
}

/**
 * Takes out the top index in a priority queue
 *
 * @param train The priority queue that contains load time
 * @return Returns the first index in priority queue
 */
int dequeue(PriorityQueue *train)
{
    if (train->size == 0)
    {
        printf("Priority Queue is empty\n");
        return -1;
    }

    int eject = train->train_index[0];
    char eject_dir = train->t_dir[0];

    train->train_index[0] = train->train_index[train->size - 1];
    train->t_dir[0] = train->t_dir[train->size - 1];
    train->ready_time[0] = train->ready_time[train->size - 1];

    train->size--;

    if (train->size > 0)
    {
        heapifyDown(train, 0);
    }

    return eject;
}

/**
 * Peeks at the first item in the priority queue
 *
 * @param train The priority queue that contains load time
 * @return Returns the first index in priority queue
 */
int peek(PriorityQueue *train)
{
    if (train->size == 0)
    {
        printf("Train is empty\n");
        return -1;
    }
    return train->train_index[0];
}

PriorityQueue train_west = {{0}, 0}; /* Initialized priority queue */
PriorityQueue train_east = {{0}, 0};
int consecutive_west = 0; /* Counts how many trains have gone consecutively west */
int consecutive_east = 0; /* Counts how many trains have gone consecutively east */

struct timespec start, end; /* Beginning and end of clock timer */
long elapsed_seconds = 0;
long elapsed_nanoseconds = 0;

/**
 * starts a timer using clock_gettime()
 */
void begin_time()
{
    int time = clock_gettime(CLOCK_REALTIME, &start);

    if (time == -1)
    {
        printf("Error in time\n");
        return;
    }
}

struct train train_data[75];      /* Holds train attributes */
pthread_mutex_t count_mutex;      /* Holds mutex */
pthread_mutex_t train_mutex_west; /* Locks the enqueue for west train */
pthread_mutex_t train_mutex_east; /* Locks the enqueue for east train */
pthread_mutex_t track;            /* General lock for both east and west train */

pthread_cond_t count_cond; /* Holds conditions */

int load_done = 0; /* Checks if loading time is done. 0: Not done, 1: done */
int load_done2 = 0;

/**
 * Prints the current time into a buffer 
 * 
 * @param buffer Where the outputted date will be stored on
 * @param size The size of the buffer
 */
void get_time(char *buffer, size_t size)
{
    int time = clock_gettime(CLOCK_REALTIME, &end); /* Retrieves the current time */
    if (time == -1)
    {
        printf("Clock error\n");
        return;
    }

    /* Line 275 - 290: Generated by ChatGPT */
    elapsed_seconds = end.tv_sec - start.tv_sec;
    elapsed_nanoseconds = end.tv_nsec - start.tv_nsec;

    if (elapsed_nanoseconds < 0)
    {
        elapsed_seconds -= 1;
        elapsed_nanoseconds += 1000000000;
    }

    int hours = elapsed_seconds / 3600;
    int minutes = (elapsed_seconds % 3600) / 60;
    int seconds = elapsed_seconds % 60;
    int milliseconds = elapsed_nanoseconds / 1000000;

    snprintf(buffer, size, "%02d:%02d:%02d.%01d", hours, minutes, seconds, milliseconds / 100); /* Stores time into buffer */
}

/**
 * Loads the train threads using usleep() and loading time
 *
 * @param index The index of current train being loaded
 */
void *loading_time(void *index)
{
    char *train_direction_l = train_data[(intptr_t)index].train_direction; /* Current train direction */
    int load_time_l = train_data[(intptr_t)index].load_time; /* Current train load time */
    int index_l = (intptr_t)index; /* Current index as int type */

    double new_time = (double)(load_time_l) / 10;
    unsigned int load_time2 = new_time * 1000000;
    usleep(load_time2); /* Loads time */

    char time_buffer[20]; /* Buffer which will hold timestamp */
    get_time(time_buffer, sizeof(time_buffer));

    pthread_mutex_lock(&count_mutex);
    char *direction;
    if (strcmp(train_direction_l, "W") == 0 || strcmp(train_direction_l, "w") == 0)
    {
        direction = "West";
    }
    else
    {
        direction = "East";
    }

    printf("%s Train %2d is ready to go %s\n", time_buffer, index_l, direction);

    pthread_mutex_unlock(&count_mutex);
    double ready_timestamp = elapsed_seconds + elapsed_nanoseconds / 1e9;
    if (strcmp(train_direction_l, "W") == 0 || strcmp(train_direction_l, "w") == 0)
    {
        pthread_mutex_lock(&train_mutex_west);
        enqueue(&train_west, train_data[index_l].train_direction[0], index_l, ready_timestamp);
        pthread_mutex_unlock(&train_mutex_west);
    }
    else
    {
        pthread_mutex_lock(&train_mutex_east);
        enqueue(&train_east, train_data[index_l].train_direction[0], index_l, ready_timestamp);
        pthread_mutex_unlock(&train_mutex_east);
    }

    pthread_mutex_lock(&count_mutex);
    load_done = 1;
    pthread_cond_broadcast(&count_cond); /* Signals load time is finished */
    pthread_mutex_unlock(&count_mutex);

    pthread_exit(NULL);
}

/**
 * Where train enters track and exits track
 *
 * @param index The index of the current train on the track
 */
void *train_departs(void *index)
{

    int t_ind = (intptr_t)index; /* Current index as int type */
    char time_buffer[20];  /* Buffers that hold the time when train gets ON the track */
    char time_buffer2[20];  /* Buffers that hold the time when train gets OFF the track */

    char *t_dir = train_data[t_ind].train_direction;
    int cross_time_l = train_data[t_ind].cross_time;

    double new_cross_time = (double)(cross_time_l) / 10;
    unsigned int load_time2 = (unsigned int)((cross_time_l / 10.0) * 1000000);

    char *dir;
    if (strcmp(t_dir, "W") == 0 || strcmp(t_dir, "w") == 0)
    {
        dir = "West";
    }
    else
    {
        dir = "East";
    }

    pthread_mutex_lock(&track);

    get_time(time_buffer, sizeof(time_buffer));

    pthread_mutex_lock(&count_mutex);
    /* Output that train is on main track */
    printf("%s Train %2d is ON the main track going %4s\n", time_buffer, t_ind, dir);
    pthread_mutex_unlock(&count_mutex);

    usleep(load_time2); /* Loads time */
    get_time(time_buffer2, sizeof(time_buffer2));

    pthread_mutex_lock(&count_mutex);
    /* Output that train is OFF the main track */
    printf("%s Train %2d is OFF the main track after going %4s\n", time_buffer2, t_ind, dir);
    pthread_mutex_unlock(&count_mutex);
    pthread_mutex_unlock(&track);

    pthread_exit(NULL);
}

/**
 * Finds the next train index to access
 *
 * @return The next index to access
 */
int find_index()
{
    int train_ind_wl = train_west.train_index[0]; /* West and east index */
    int train_ind_el = train_east.train_index[0];

    double train_wl_load = train_west.ready_time[0]; /* West and east ready times */
    double train_el_load = train_east.ready_time[0];

    int train_wl_priority = get_priority(train_west.t_dir[0]); /* West and east priority */
    int train_el_priority = get_priority(train_east.t_dir[0]);

    if (train_west.size < 1 && train_east.size < 1) /* Empty queue */
    { 
        return -1;
    }

    if (train_west.size == 0 && train_east.size > 0) /* Train is only going west*/
    { 
        consecutive_east++;
        consecutive_west = 0;
        return peek(&train_east);
    }

    if (train_west.size > 0 && train_east.size == 0) /* Train is only going east */
    { 
        consecutive_west++;
        consecutive_east = 0;
        return peek(&train_west);
    }

    if (consecutive_west > 1) /* Trains have gone west more than once consecutively */
    {
        consecutive_east++;
        consecutive_west = 0;
        return peek(&train_east);
    }

    if (consecutive_east > 1) /* Trains have gone east more than once consecutively */
    {
        consecutive_east = 0;
        consecutive_west++;
        return peek(&train_west);
    }

    if (train_wl_priority > train_el_priority) /* West Train has higher priority than east */
    {
        consecutive_west++;
        consecutive_east = 0;
        return peek(&train_west);
    }

    if (train_wl_priority < train_el_priority) /* West Train has higher priority than east */
    {
        consecutive_east++;
        consecutive_west = 0;
        return peek(&train_east);
    }

    if (train_wl_load < train_el_load) /* West train has shorter load time than east */
    {
        consecutive_west++;
        if (consecutive_west > 1) /* Check to see if it will be the second train to cross west consecutively */
        {
            consecutive_west = 0;
            consecutive_east++;
            return peek(&train_east);
        }
        else
        {
            consecutive_east = 0;
            return peek(&train_west);
        }
    }

    if (train_wl_load > train_el_load) /* East train has shorter load time than west */
    {
        consecutive_east++;
        if (consecutive_east > 1) /* Check to see if it will be the second train to cross east consecutively */
        {
            consecutive_east = 0;
            consecutive_west++;
            return peek(&train_west);
        }
        else
        {
            consecutive_west = 0;
            return peek(&train_east);
        }
    }

}

int main(int argc, char **argv)
{
    pthread_t threads[75]; /* Threads used to load trains */
    pthread_t thread2[75]; /* Threads used to put train on and off track */

    int next_index = -1; /* Contains the next index to dequeue */

    pthread_mutex_init(&count_mutex, NULL); /* Initializes mutexes */
    pthread_mutex_init(&train_mutex_west, NULL);
    pthread_mutex_init(&train_mutex_east, NULL);
    pthread_mutex_init(&track, NULL);

    pthread_cond_init(&count_cond, NULL); /* Initializes condition */

    FILE *input = fopen(argv[1], "r");
    if (input == NULL)
    {
        printf("Error: File is not available\n");
        return -1;
    }

    int num_trains = 0; /* Scans and gets the train data onto struct */
    while (!feof(input))
    {
        fscanf(input, "%s %d %d\n", train_data[num_trains].train_direction, &train_data[num_trains].load_time, &train_data[num_trains].cross_time);
        num_trains++;
    }

    begin_time(); /* Begins clock timer */

    for (int i = 0; i < num_trains; i++)
    {
        pthread_create(&threads[i], NULL, loading_time, (void *)(intptr_t)i); /* Loads the trains and decides which train to enter the main track */
    }

    int completed_trains = 0; /* Tracks the amount of trains loaded, travelled and completed travel on the main track */
    while (completed_trains < num_trains) 
    {

        pthread_mutex_lock(&count_mutex);
        while (train_west.size == 0 && train_east.size == 0) /* Loop waits for loading time to be complete - Source: ChatGPT (for while condition) */
        {
            pthread_cond_wait(&count_cond, &count_mutex);
        }

        next_index = find_index();
        if (next_index == -1)
        {
            pthread_mutex_unlock(&count_mutex);
            break;
        }

        if (train_data[next_index].train_direction[0] == 'W' || train_data[next_index].train_direction[0] == 'w') /* Dequeues based on direction */
        {
            dequeue(&train_west);
        }
        else
        {
            dequeue(&train_east);
        }

        pthread_mutex_unlock(&count_mutex);

        pthread_create(&thread2[completed_trains], NULL, train_departs, (void *)(intptr_t)next_index); /* Creates thread which decides what train crosses the track */
        pthread_join(thread2[completed_trains], NULL);

        completed_trains++;
    }

    for (int i = 0; i < num_trains; i++)
    {
        pthread_join(threads[i], NULL); /* Wait for threads to all complete */
    }

    pthread_mutex_destroy(&count_mutex); /* Destroys mutexes */
    pthread_mutex_destroy(&train_mutex_west);
    pthread_mutex_destroy(&train_mutex_east);
    pthread_mutex_destroy(&track);

    pthread_cond_destroy(&count_cond); /* Destroys conditin */

    pthread_exit(NULL);
}