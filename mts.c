#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <sys/wait.h>

int consecutive_west = 0;
int consecutive_east = 0;
/**
 * Struct contains train data
 */
struct train
{

    char train_direction[2];
    int load_time;
    int cross_time;
};

/**
 * Gets the priority of the train direction
 *
 * @param dir The direction of the train and priority
 * @return The priority
 *
 * Generated by ChatGPT
 */
int get_priority(char dir)
{
    if (dir == 'W' || dir == 'E')
        return 2; // High priority
    if (dir == 'w' || dir == 'e')
        return 1; // Low priority
    return 0;     // Invalid case (should not happen)
}

/*
    Priority Queue Implementation
    Sources - https://www.geeksforgeeks.org/c-program-to-implement-priority-queue/ & ChatGPT
*/

typedef struct
{
    char t_dir[75];
    int train_index[75];
    // temp
    double ready_time[75];
    // temp
    int size;
} PriorityQueue;

/**
 * Swaps two char variables
 *
 * @param a1 The first variable that swaps with a2
 * @param a2 The second variable that swaps with a1
 */
void swap2(char *a1, char *a2)
{
    char temp = *a1;
    *a1 = *a2;
    *a2 = temp;
}

/**
 * Swaps two int variables
 *
 * @param a1 The first variable that swaps with a2
 * @param a2 The second variable that swaps with a1
 */
void swap(int *a1, int *a2)
{
    int temp = *a1;
    *a1 = *a2;
    *a2 = temp;
}

/**
 * Checks if the min heap structure is maintained. If not, then it will correct it by comparing
 * if the parent is greater than child. Swaps anything that is true to the statement.
 *
 * @param train A priority queue which holds the loading_time for the train
 * @param index The index of the current train
 */
void heapifyUp(PriorityQueue *train, int index)
{
    if (index == 0)
    {
        return;
    }

    int parent = (index - 1) / 2;

    int curr_priority = get_priority(train->t_dir[index]);
    int parent_priority = get_priority(train->t_dir[parent]);

    if (curr_priority > parent_priority ||
        (curr_priority == parent_priority &&
         (train->ready_time[index] < train->ready_time[parent] ||
          (train->ready_time[index] == train->ready_time[parent] && train->train_index[index] < train->train_index[parent]))))
    {
        swap2(&train->t_dir[parent], &train->t_dir[index]);
        swap(&train->train_index[parent], &train->train_index[index]);
        double temp = train->ready_time[parent];
        train->ready_time[parent] = train->ready_time[index];
        train->ready_time[index] = temp;
        heapifyUp(train, parent);
    }
}

/**
 * Adds new loading time values to priority queue
 *
 * @param train The priority queue to that holds load time
 * @param value The new train direction to be inserted into train which defines priority
 * @param value2 The new index to be inserted into train
 */
void enqueue(PriorityQueue *train, char value, int value2, double value3)
{
    if (train->size == 75)
    {
        printf("Queue is full\n");
        return;
    }

    train->t_dir[train->size] = value;
    train->train_index[train->size] = value2;
    train->ready_time[train->size] = value3;
    heapifyUp(train, train->size);
    train->size++;
}

/**
 * Checks if min heap structure is maintained at bottom.
 * If not, it will swap left or right with current index.
 *
 * @param train The priority queue that contains load time
 * @param index The index of the current train
 */
void heapifyDown(PriorityQueue *train, int index)
{
    int left = 2 * index + 1;  // Left child
    int right = 2 * index + 2; // Right child
    int highest = index;

    if (left < train->size &&
        (get_priority(train->t_dir[left]) > get_priority(train->t_dir[highest]) ||
         (get_priority(train->t_dir[left]) == get_priority(train->t_dir[highest]) &&
          (train->ready_time[left] < train->ready_time[highest] ||
           (train->ready_time[left] == train->ready_time[highest] &&
            train->train_index[left] < train->train_index[highest])))))
    {
        highest = left;
    }

    if (right < train->size &&
        (get_priority(train->t_dir[right]) > get_priority(train->t_dir[highest]) ||
         (get_priority(train->t_dir[right]) == get_priority(train->t_dir[highest]) &&
          (train->ready_time[right] < train->ready_time[highest] ||
           (train->ready_time[right] == train->ready_time[highest] && train->train_index[right] < train->train_index[highest])))))
    {
        highest = right;
    }

    if (highest != index)
    {
        swap2(&train->t_dir[index], &train->t_dir[highest]);
        swap(&train->train_index[index], &train->train_index[highest]);
        double temp = train->ready_time[highest];
        train->ready_time[highest] = train->ready_time[index];
        train->ready_time[index] = temp;
        heapifyDown(train, highest);
    }
}

/**
 * Takes out the top item in a priority queue
 *
 * @param train The priority queue that contains load time
 * @return Returns the first index in priority queue
 */
int dequeue(PriorityQueue *train)
{
    if (train->size == 0)
    {
        printf("Priority Queue is empty\n");
        return -1;
    }

    int eject = train->train_index[0];
    char eject_dir = train->t_dir[0];

    train->train_index[0] = train->train_index[train->size - 1];
    train->t_dir[0] = train->t_dir[train->size - 1];
    train->ready_time[0] = train->ready_time[train->size - 1];

    train->size--;

    if (train->size > 0)
    {
        heapifyDown(train, 0);
    }

    return eject;
}

/**
 * Peeks at the first item in the priority queue
 *
 * @param train The priority queue that contains load time
 * @return Returns the first index in priority queue
 */
int peek(PriorityQueue *train)
{
    if (train->size == 0)
    {
        printf("Train is empty\n");
        return -1;
    }
    return train->train_index[0];
}

PriorityQueue train_west = {{0}, 0}; /* Initialized priority queue */
PriorityQueue train_east = {{0}, 0};

struct timespec start, end; /* Beginning and end of clock timer */
long elapsed_seconds = 0;
long elapsed_nanoseconds = 0;

/**
 * Begins a timer
 */
void begin_time()
{
    int time = clock_gettime(CLOCK_REALTIME, &start);

    if (time == -1)
    {
        printf("Error in time\n");
        return;
    }
}

struct train train_data[75]; /* Holds train attributes */
pthread_mutex_t count_mutex; /* Holds mutex */
pthread_mutex_t main_lock;   /* locks the main function */
pthread_mutex_t train_mutex_west;
pthread_mutex_t train_mutex_east;
pthread_mutex_t track;

pthread_cond_t count_cond; /* Holds conditions */
pthread_cond_t count_cond2;

int load_done = 0; /* Checks if loading time is done. 0: Not done, 1: done */
int load_done2 = 0;
char last_direction = 'E';

/**
 * Prints the current time
 */
void get_time(char *buffer, size_t size)
{
    int time = clock_gettime(CLOCK_REALTIME, &end);

    if (time == -1)
    {
        printf("Clock error");
        return;
    }

    /* Line 195 - 211: Generated by ChatGPT */
    elapsed_seconds = end.tv_sec - start.tv_sec;
    elapsed_nanoseconds = end.tv_nsec - start.tv_nsec;

    if (elapsed_nanoseconds < 0)
    {
        elapsed_seconds -= 1;
        elapsed_nanoseconds += 1000000000;
    }

    int hours = elapsed_seconds / 3600;
    int minutes = (elapsed_seconds % 3600) / 60;
    int seconds = elapsed_seconds % 60;
    int milliseconds = elapsed_nanoseconds / 1000000;

    snprintf(buffer, size, "%02d:%02d:%02d.%01d", hours, minutes, seconds, milliseconds / 100);
}

/**
 * Loads the train threads using usleep() and loading time
 *
 * @param index The index of current train being loaded
 */
void *loading_time(void *index)
{
    char *train_direction_l = train_data[(intptr_t)index].train_direction;
    int load_time_l = train_data[(intptr_t)index].load_time;
    int index_l = (intptr_t)index;

    double new_time = (double)(load_time_l) / 10;
    unsigned int load_time2 = new_time * 1000000;
    usleep(load_time2); /* Loads time */

    char time_buffer[20]; // Buffer to hold formatted timestamp
    get_time(time_buffer, sizeof(time_buffer));

    pthread_mutex_lock(&count_mutex);
    char *direction;
    if (strcmp(train_direction_l, "W") == 0 || strcmp(train_direction_l, "w") == 0)
    {
        direction = "West";
    }
    else
    {
        direction = "East";
    }

    printf("%s Train %2d is ready to go %s\n", time_buffer, index_l, direction);

    pthread_mutex_unlock(&count_mutex);
    double ready_timestamp = elapsed_seconds + elapsed_nanoseconds / 1e9; // temp
    if (strcmp(train_direction_l, "W") == 0 || strcmp(train_direction_l, "w") == 0)
    {
        pthread_mutex_lock(&train_mutex_west);
        enqueue(&train_west, train_data[index_l].train_direction[0], index_l, ready_timestamp); // temp: remove read_timestamp
        pthread_mutex_unlock(&train_mutex_west);
    }
    else
    {
        pthread_mutex_lock(&train_mutex_east);
        enqueue(&train_east, train_data[index_l].train_direction[0], index_l, ready_timestamp);
        pthread_mutex_unlock(&train_mutex_east);
    }

    pthread_mutex_lock(&count_mutex);
    load_done = 1;
    pthread_cond_broadcast(&count_cond); /* Signals load time is finished */
    pthread_mutex_unlock(&count_mutex);

    pthread_exit(NULL);
}

/**
 * Where train enters track and exits track
 *
 * @param index The index of the current train on the track
 */
void *train_departs(void *index)
{

    int t_ind = (intptr_t)index;
    char time_buffer2[20]; /* Buffers that hold the time */
    char time_buffer[20];

    /* Output train on track */
    char *t_dir = train_data[t_ind].train_direction;
    int cross_time_l = train_data[t_ind].cross_time;

    double new_cross_time = (double)(cross_time_l) / 10;
    unsigned int load_time2 = (unsigned int)((cross_time_l / 10.0) * 1000000);

    char *dir;
    if (strcmp(t_dir, "W") == 0 || strcmp(t_dir, "w") == 0)
    {
        dir = "West";
    }
    else
    {
        dir = "East";
    }

    pthread_mutex_lock(&track);

    get_time(time_buffer, sizeof(time_buffer));

    pthread_mutex_lock(&count_mutex);
    /* Output that train is on main track */
    printf("%s Train %2d is ON the main track going %4s\n", time_buffer, t_ind, dir);
    pthread_mutex_unlock(&count_mutex);

    usleep(load_time2); /* Loads time */
    get_time(time_buffer2, sizeof(time_buffer2));

    pthread_mutex_lock(&count_mutex);
    /* Output that train is OFF the main track */
    printf("%s Train %2d is OFF the main track after going %4s\n", time_buffer2, t_ind, dir);
    pthread_mutex_unlock(&count_mutex);
    pthread_mutex_unlock(&track);

    pthread_exit(NULL);
}

/**
 * Finds the next train index to access
 *
 * @return The next index to access
 */
int find_index()
{
   // printf("current size is: %d\n", train_west.size + train_east.size);

    int train_ind_wl = train_west.train_index[0];
    int train_ind_el = train_east.train_index[0];

    double train_wl_load = train_west.ready_time[0];
    double train_el_load = train_east.ready_time[0];

    int train_wl_priority = get_priority(train_west.t_dir[0]);
    int train_el_priority = get_priority(train_east.t_dir[0]);

    if (train_west.size < 1 && train_east.size < 1)
    { /* Empty queue */
        return -1;
    }

    if (train_west.size == 0 && train_east.size > 0)
    { /* Train is only going west*/
        consecutive_east++;
        consecutive_west = 0;
        last_direction = 'E';
        return peek(&train_east);
    }

    if (train_west.size > 0 && train_east.size == 0)
    { /* Train is only going east */
        consecutive_west++;
        consecutive_east = 0;
        last_direction = 'W';
        return peek(&train_west);
    }

    if(consecutive_west > 1){
        return peek(&train_east);
    }

    if(consecutive_east > 1){
        return peek(&train_west);
    }

   // printf("Consecutive west = %d\n", consecutive_west);

    if (train_wl_load < train_el_load)
    {
        consecutive_west++;
        consecutive_east = 0;
        last_direction = 'W';
        return peek(&train_west);
    }

  //  if(train_ind_el == 0){
        //return peek(&train_east);
   /*      printf("0 goes first\n");
    }
    if(train_ind_wl == 3){
        printf("3 goes next?\n");
    } */


    if (train_wl_load > train_el_load)
    {
        consecutive_east++;
        consecutive_west = 0;
        last_direction = 'E';
        return peek(&train_east);
    }

    if (train_wl_priority > train_el_priority)
    {
        consecutive_west++;
        consecutive_east = 0;
        last_direction = 'W';
        return peek(&train_west);
    }

    if (train_wl_priority < train_el_priority)
    {
        consecutive_east++;
        consecutive_west = 0;
        last_direction = 'E';
        return peek(&train_east);
    }

    if (consecutive_west >= 2) {
        consecutive_east = 1;
        consecutive_west = 0;
        last_direction = 'E';
        return peek(&train_east);
    }

    if (consecutive_east >= 2) {
        consecutive_west = 1;
        consecutive_east = 0;
        last_direction = 'W';
        return peek(&train_west);
    }


    if (last_direction == 'W')
    {
        consecutive_east++;
        consecutive_west = 0;
        last_direction = 'E';
        return peek(&train_east);
    }
    else
    {
        consecutive_west++;
        consecutive_east = 0;
        last_direction = 'W';
        return peek(&train_west);
    }

    return -1;
}

int main(int argc, char **argv)
{
    pthread_t threads[75];
    pthread_t thread2[75];

    int j = -1;

    pthread_mutex_init(&count_mutex, NULL); /* Initializes mutex */
    pthread_mutex_init(&main_lock, NULL);
    pthread_mutex_init(&train_mutex_west, NULL);
    pthread_mutex_init(&train_mutex_east, NULL);
    pthread_mutex_init(&track, NULL);

    pthread_cond_init(&count_cond, NULL); /* Initializes condition */
    pthread_cond_init(&count_cond2, NULL);

    FILE *input = fopen(argv[1], "r");
    if (input == NULL)
    {
        printf("Error: File is not available\n");
        return -1;
    }

    int num_trains = 0; /* Scans and gets the train data onto struct */
    while (!feof(input))
    {
        fscanf(input, "%s %d %d\n", train_data[num_trains].train_direction, &train_data[num_trains].load_time, &train_data[num_trains].cross_time);
        num_trains++;
    }

    begin_time(); /* Begins clock timer */

    for (int i = 0; i < num_trains; i++)
    {
        pthread_create(&threads[i], NULL, loading_time, (void *)(intptr_t)i); /* Loads the trains and decides which train to enter the main track */
    }

    int completed_trains = 0;
    while(completed_trains < num_trains){

        pthread_mutex_lock(&count_mutex);
       while(train_west.size == 0 && train_east.size == 0)
        {
            pthread_cond_wait(&count_cond, &count_mutex);
        }

        int j = find_index();
        if (j == -1)
        {
            pthread_mutex_unlock(&count_mutex);
            break;
        }

        if (train_data[j].train_direction[0] == 'W' || train_data[j].train_direction[0] == 'w')
        {
            dequeue(&train_west);
        }
        else
        {
            dequeue(&train_east);
        }
      //  printf("Dequeued() Train %d\n", j);
        pthread_mutex_unlock(&count_mutex);

        pthread_create(&thread2[completed_trains], NULL, train_departs, (void *)(intptr_t)j);
        pthread_join(thread2[completed_trains], NULL);

        completed_trains++;
    }

    for (int i = 0; i < num_trains; i++)
    {
        pthread_join(threads[i], NULL); /* Wait for threads to all complete */
    }

    pthread_mutex_destroy(&count_mutex);
    pthread_mutex_destroy(&main_lock);
    pthread_mutex_destroy(&train_mutex_west);
    pthread_mutex_destroy(&train_mutex_east);
    pthread_mutex_destroy(&track);

    pthread_cond_destroy(&count_cond);
    pthread_cond_destroy(&count_cond2);

    pthread_exit(NULL);
}